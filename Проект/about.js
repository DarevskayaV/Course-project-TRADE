// =============================================================================
// ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ (ООП) В JAVASCRIPT
// 
// Класс Employee представляет концепцию "Сотрудник" в бизнес-логике приложения
// Это пример МОДЕЛИ ДАННЫХ (Data Model) в архитектуре MVC
// =============================================================================

/**
 * КЛАСС Employee - ШАБЛОН ДЛЯ СОЗДАНИЯ ОБЪЕКТОВ СОТРУДНИКОВ
 * 
 * ТЕОРИЯ: Класс в JavaScript - это синтаксический сахар над прототипным наследованием
 * Классы представляют собой "чертежи" для создания объектов с одинаковой структурой
 * 
 * ПРИНЦИПЫ ООП, реализованные здесь:
 * - ИНКАПСУЛЯЦИЯ: данные и методы работы с ними объединены в одном классе
 * - АБСТРАКЦИЯ: скрывает сложность реализации, предоставляя простой интерфейс
 */
class Employee {
  
  /**
   * КОНСТРУКТОР КЛАССА - специальный метод для инициализации новых объектов
   * 
   * ТЕОРИЯ: Конструктор вызывается при создании экземпляра класса с помощью 'new'
   * Его задача - установить начальное состояние объекта
   * 
   * @param {string} name - имя сотрудника
   * @param {string} surname - фамилия сотрудника  
   * @param {string} position - должность
   * @param {string} quote - цитата/девиз
   * @param {string} imagePath - путь к фотографии
   */
  constructor(name, surname, position, quote, imagePath) {
    // =========================================================================
    // ИНИЦИАЛИЗАЦИЯ СВОЙСТВ ЭКЗЕМПЛЯРА (INSTANCE PROPERTIES)
    // =========================================================================
    
    /**
     * this - ключевое слово, ссылающееся на ТЕКУЩИЙ ЭКЗЕМПЛЯР класса
     * 
     * ТЕОРИЯ: Когда создается новый объект через 'new Employee()',
     * 'this' внутри конструктора ссылается на этот новый объект
     */
    this.name = name;
    this.surname = surname;
    this.position = position;
    this.quote = quote;
    this.imagePath = imagePath;
    
    /**
     * ТЕОРИЯ О СТРУКТУРЕ ОБЪЕКТА:
     * После выполнения конструктора, каждый объект Employee будет иметь:
     * {
     *   name: "Анна",
     *   surname: "Иванова", 
     *   position: "Основатель и дизайнер",
     *   quote: "Красота — это гармония...",
     *   imagePath: "images/employees/Hanna_Ivanova.jpg"
     * }
     */
  }

  // ===========================================================================
  // МЕТОДЫ КЛАССА - ПОВЕДЕНИЕ ОБЪЕКТОВ (BEHAVIOR)
  // ===========================================================================

  /**
   * МЕТОД render() - ОТВЕЧАЕТ ЗА ПРЕДСТАВЛЕНИЕ ДАННЫХ В HTML
   * 
   * ТЕОРИЯ: Этот метод реализует принцип "ОТВЕТСТВЕННОСТИ" - каждый класс
   * должен отвечать за одну конкретную задачу. Employee знает как "отрисовать" себя
   * 
   * ПАТТЕРН: Метод render() часто используется в компонентном подходе
   * (React, Vue, Angular) для отделения данных от их представления
   * 
   * @returns {HTMLElement} - готовый DOM-элемент для вставки на страницу
   */
  render() {
    /**
     * СОЗДАНИЕ DOM-ЭЛЕМЕНТА
     * document.createElement() - создает элемент в памяти (не на странице)
     * 
     * ТЕОРИЯ: DOM (Document Object Model) - программное представление HTML-страницы
     * JavaScript может манипулировать DOM для динамического изменения контента
     */
    const memberDiv = document.createElement("div");
    
    /**
     * ДОБАВЛЕНИЕ CSS-КЛАССА ДЛЯ СТИЛИЗАЦИИ
     * classList.add() - добавляет класс к элементу
     * 
     * ТЕОРИЯ: CSS-классы позволяют отделить стилизацию от структуры
     * Класс 'team-member' будет стилизован в style.css
     */
    memberDiv.classList.add("team-member");

    /**
     * ЗАПОЛНЕНИЕ HTML-СОДЕРЖИМОГО С ИСПОЛЬЗОВАНИЕМ ДАННЫХ ОБЪЕКТА
     * Шаблонные строки (template literals) позволяют вставлять переменные через ${}
     * 
     * ТЕОРИЯ: innerHTML парсит строку как HTML и создает соответствующие DOM-элементы
     * Альтернатива: создавать каждый элемент отдельно через createElement()
     * 
     * СЕМАНТИКА HTML-СТРУКТУРЫ:
     * - <img> - фотография сотрудника с alt-текстом для доступности
     * - <h3> - заголовок с именем и фамилией (иерархия заголовков)
     * - <p class="position"> - должность с семантическим классом
     * - <blockquote> - цитата (семантический тег для цитирования)
     */
    memberDiv.innerHTML = `
      <img src="${this.imagePath}" alt="${this.name} ${this.surname}" />
      <h3>${this.name} ${this.surname}</h3>
      <p class="position">${this.position}</p>
      <blockquote>${this.quote}</blockquote>
    `;

    /**
     * ВОЗВРАТ СОЗДАННОГО ЭЛЕМЕНТА
     * Важно: элемент пока НЕ добавлен на страницу, только создан в памяти
     */
    return memberDiv;
  }
}

// =============================================================================
// СОЗДАНИЕ КОЛЛЕКЦИИ ДАННЫХ (DATA COLLECTION)
// =============================================================================

/**
 * МАССИВ employees - КОЛЛЕКЦИЯ ВСЕХ СОТРУДНИКОВ КОМПАНИИ
 * 
 * ТЕОРИЯ: Массив - это упорядоченная коллекция элементов
 * Здесь мы создаем МАССИВ ОБЪЕКТОВ, где каждый объект - экземпляр класса Employee
 * 
 * ПАТТЕРН: Это пример "Источника данных" (Data Source) или "Репозитория" (Repository)
 */
const employees = [
  /**
   * СОЗДАНИЕ ЭКЗЕМПЛЯРОВ КЛАССА Employee
   * new Employee() - оператор создания нового объекта по шаблону класса
   * 
   * ТЕОРИЯ: Процесс создания объекта:
   * 1. Выделяется память для нового объекта
   * 2. Вызывается constructor() с переданными аргументами  
   * 3. Возвращается готовый объект
   */
  new Employee(
    "Анна",                              // name
    "Иванова",                           // surname
    "Основатель и дизайнер",             // position
    "Красота — это гармония души и деталей вокруг нас.", // quote
    "images/employees/Hanna_Ivanova.jpg" // imagePath
  ),
  
  new Employee(
    "Мартин",
    "Петров", 
    "Менеджер по продажам",
    "Улыбка — лучший способ сделать день приятнее.",
    "images/employees/Martin_Petrov.jpg"
  ),
  
  new Employee(
    "Екатерина",
    "Смирнова",
    "Фотограф и контент-создатель", 
    "Каждый момент — это история, которую стоит сохранить.",
    "images/employees/Ekaterina_Smirnova.jpg"
  ),
  
  new Employee(
    "Алексей",
    "Кузнецов",
    "Технический специалист",
    "Совершенство — это когда работает просто и красиво.",
    "images/employees/Aleksey_Kuznetsov.jpg"
  ),
  
  new Employee(
    "Ольга", 
    "Васильева",
    "Маркетолог",
    "Правильное сообщение достигает сердца каждого.",
    "images/employees/Olga_Vasilieva.jpg"
  ),
  
  new Employee(
    "Игорь",
    "Новиков",
    "Разработчик",
    "Код — это инструмент для воплощения идей.", 
    "images/employees/Igor_Novikov.jpg"
  ),
  
  new Employee(
    "Мария",
    "Соколова",
    "Копирайтер",
    "Слова имеют силу менять восприятие мира.",
    "images/employees/Maria_Sokolova.jpg"
  ),
  
  new Employee(
    "Дмитрий",
    "Лебедев", 
    "SEO-специалист",
    "Каждый сайт заслуживает быть найденным.",
    "images/employees/Dmitry_Lebedev.jpg"
  ),
  
  new Employee(
    "Елена",
    "Морозова",
    "PR-менеджер",
    "История компании важна так же, как и её будущее.",
    "images/employees/Elena_Morozova.jpg"
  )
];

// =============================================================================
// ПРОЦЕСС ОТРИСОВКИ ДАННЫХ НА СТРАНИЦЕ (RENDERING PROCESS)
// =============================================================================

/**
 * ПОЛУЧЕНИЕ ССЫЛКИ НА КОНТЕЙНЕР ДЛЯ КОМАНДЫ
 * document.getElementById() - ищет элемент по его уникальному id
 * 
 * ТЕОРИЯ: DOM-запросы (querying) - поиск элементов на странице
 * Альтернативы: querySelector(), querySelectorAll(), getElementsByClassName()
 */
const teamSection = document.getElementById("team");

/**
 * ПРОЦЕСС ДОБАВЛЕНИЯ ВСЕХ СОТРУДНИКОВ НА СТРАНИЦУ
 * 
 * ТЕОРИЯ: Это пример "Императивного программирования" - мы явно говорим
 * КАК выполнить задачу (пройти по массиву и добавить каждый элемент)
 */
employees.forEach(employee => {
  /**
   * ДЛЯ КАЖДОГО СОТРУДНИКА В МАССИВЕ:
   * 1. Вызываем метод render() который возвращает готовый DOM-элемент
   * 2. Добавляем этот элемент в контейнер teamSection
   * 
   * ТЕОРИЯ: forEach() - метод массива для итерации по элементам
   * Альтернативы: for...of, for, map()
   */
  const employeeElement = employee.render();
  
  /**
   * appendChild() - ДОБАВЛЯЕТ ЭЛЕМЕНТ КАК ПОСЛЕДНЕГО РЕБЕНКА РОДИТЕЛЯ
   * 
   * ТЕОРИЯ: DOM-дерево имеет иерархическую структуру
   * appendChild() физически добавляет элемент на страницу
   * 
   * ПРОЦЕСС ДОБАВЛЕНИЯ:
   * 1. Создан элемент в памяти (employee.render())
   * 2. Элемент добавляется в DOM-дерево (appendChild())
   * 3. Браузер перерисовывает страницу (reflow/repaint)
   */
  teamSection.appendChild(employeeElement);
});

/**
 * АЛЬТЕРНАТИВНАЯ ЗАПИСЬ С ИСПОЛЬЗОВАНИЕМ ЦИКЛА for...of:
 * 
 * for (const employee of employees) {
 *   teamSection.appendChild(employee.render());
 * }
 * 
 * ИЛИ С ИСПОЛЬЗОВАНИЕМ ОБЫЧНОГО ЦИКЛА for:
 * 
 * for (let i = 0; i < employees.length; i++) {
 *   teamSection.appendChild(employees[i].render());
 * }
 */