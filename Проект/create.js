// =============================================================================
// ГЛОБАЛЬНЫЙ КОНТЕКСТ И ПЕРЕМЕННЫЕ В JAVASCRIPT
// =============================================================================

/**
 * ТЕОРИЯ: Execution Context (Контекст выполнения) в JavaScript
 * 
 * 1. Global Execution Context:
 *    - Создается при загрузке скрипта
 *    - Содержит глобальные переменные и функции
 *    - `this` ссылается на window (в браузере)
 * 
 * 2. Variable Environment (Окружение переменных):
 *    - Хранит объявления переменных и функций
 *    - Обрабатывает hoisting (поднятие)
 * 
 * 3. Scope Chain (Цепочка областей видимости):
 *    - Определяет доступность переменных
 *    - Лексическое окружение (Lexical Environment)
 */

// === НАХОДИМ ВСЕ НУЖНЫЕ ЭЛЕМЕНТЫ НА СТРАНИЦЕ ===

/**
 * ТЕОРИЯ: Document Object Model (DOM) - Программный интерфейс для HTML/XML
 * 
 * История DOM:
 * - DOM Level 0 (1996): Неформальный стандарт (images[], forms[])
 * - DOM Level 1 (1998): Первая стандартизация W3C
 * - DOM Level 2 (2000): События, CSS, обход дерева
 * - DOM Level 3 (2004): XPath, загрузка/сохранение
 * - DOM Level 4 (2015): Современный стандарт (Living Standard)
 * 
 * DOM Tree Structure:
 * - Document: Корневой узел
 * - Element: HTML элементы (<div>, <p>)
 * - Attr: Атрибуты элементов
 * - Text: Текстовое содержимое
 * - Comment: Комментарии
 */

// Находим форму для создания товара
/**
 * ТЕОРИЯ: document.getElementById() vs другие методы поиска
 * 
 * Методы поиска элементов:
 * 1. getElementById(): Возвращает один элемент по ID
 * 2. getElementsByClassName(): Live HTMLCollection по классу
 * 3. getElementsByTagName(): Live HTMLCollection по тегу
 * 4. querySelector(): Первый элемент по CSS селектору
 * 5. querySelectorAll(): Static NodeList по CSS селектору
 * 
 * Производительность:
 * - getElementById() самый быстрый (оптимизация браузеров)
 * - querySelector удобнее для сложных селекторов
 * - Live vs Static коллекции
 */
const form = document.getElementById('productForm');

// Находим выпадающий список категорий
/**
 * ТЕОРИЯ: HTMLSelectElement - специализированный интерфейс для <select>
 * 
 * Свойства и методы:
 * - options: Коллекция <option> элементов
 * - selectedIndex: Индекс выбранной опции
 * - value: Значение выбранной опции
 * - add(): Добавление новой опции
 * - remove(): Удаление опции по индексу
 */
const categorySelect = document.getElementById('category');

// Находим место для сообщений
/**
 * ТЕОРИЯ: HTMLElement интерфейс
 * 
 * Важные свойства:
 * - style: Доступ к CSS стилям
 * - textContent: Текстовое содержимое
 * - innerHTML: HTML содержимое
 * - classList: Управление CSS классами
 * - dataset: Доступ к data-* атрибутам
 */
const message = document.getElementById('formMessage');

// Находим поле для загрузки картинки
/**
 * ТЕОРИЯ: HTMLInputElement для type="file"
 * 
 * Свойства files:
 * - FileList объект (array-like)
 * - files[0]: Первый выбранный файл
 * - files.length: Количество файлов
 * - multiple: Разрешение множественного выбора
 * 
 * File API (HTML5):
 * - File: Имя, размер, тип, последнее изменение
 * - Blob: Binary Large Object - базовый интерфейс
 */
const imageInput = document.getElementById('image');

// Находим место для предпросмотра картинки
/**
 * ТЕОРИЯ: HTMLImageElement
 * 
 * Свойства:
 * - src: URL источника изображения
 * - alt: Альтернативный текст
 * - naturalWidth/Height: Реальные размеры
 * - complete: Загружено ли изображение
 * - decoding: async/sync декодирование
 */
const preview = document.getElementById('preview');

// =============================================================================
// ФУНКЦИИ И ОБЛАСТИ ВИДИМОСТИ В JAVASCRIPT
// =============================================================================

/**
 * ТЕОРИЯ: Function Declaration vs Function Expression
 * 
 * Function Declaration:
 * - Поднимается (hoisted) полностью
 * - Доступна до объявления
 * 
 * Function Expression:
 * - Поднимается только объявление переменной
 * - Доступна только после присваивания
 */

// === ФУНКЦИЯ ДЛЯ ЗАПОЛНЕНИЯ СПИСКА КАТЕГОРИЙ ===
function initCategories() {
  /**
   * ТЕОРИЯ: Object.keys() и итерация по объектам
   * 
   * Методы итерации объектов:
   * 1. Object.keys(): Массив ключей
   * 2. Object.values(): Массив значений  
   * 3. Object.entries(): Массив пар [ключ, значение]
   * 
   * Циклы для объектов:
   * - for...in: Итерация по перечисляемым свойствам
   * - Object.keys().forEach(): Функциональный подход
   */
  
  // Object.keys() - получаем все названия категорий из хранилища товаров
  Object.keys(productStore.categories).forEach(cat => {
    /**
     * ТЕОРИЯ: Arrow Functions (Стрелочные функции)
     * 
     * Отличия от обычных функций:
     * - Нет собственного `this` (наследует из внешней области)
     * - Нет arguments объекта
     * - Не могут быть конструкторами (нет prototype)
     * - Более короткий синтаксис
     */
    
    // Создаем новую строку в выпадающем списке
    /**
     * ТЕОРИЯ: document.createElement() - создание DOM элементов
     * 
     * Процесс создания элемента:
     * 1. Создается в памяти (не в DOM дереве)
     * 2. Настраиваются свойства и атрибуты
     * 3. Добавляется в DOM через appendChild()/insertBefore()
     * 
     * Альтернативы:
     * - innerHTML: Быстрое создание из строки
     * - insertAdjacentHTML(): Гибкая вставка HTML
     * - cloneNode(): Клонирование существующих элементов
     */
    const option = document.createElement('option');
    
    // Задаем значение этой строки (внутреннее имя)
    /**
     * ТЕОРИЯ: HTMLOptionElement
     * 
     * Свойства:
     * - value: Значение отправляемое на сервер
     * - text: Видимый текст
     * - selected: Выбрана ли опция
     * - defaultSelected: Значение по умолчанию
     */
    option.value = cat;
    
    // Задаем текст, который увидит пользователь
    /**
     * ТЕОРИЯ: textContent vs innerText vs innerHTML
     * 
     * textContent:
     * - Все текстовое содержимое включая скрытое
     * - Безопасно (не парсит HTML)
     * - Быстрее innerText
     * 
     * innerText:
     * - Только видимый текст
     * - Учитывает CSS стили
     * - Медленнее из-за reflow
     * 
     * innerHTML:
     * - Парсит HTML теги
     * - Риск XSS атак
     * - Для вставки HTML разметки
     */
    option.textContent = cat;
    
    // Добавляем созданную строку в выпадающий список
    /**
     * ТЕОРИЯ: DOM Manipulation - добавление элементов
     * 
     * Методы добавления:
     * - appendChild(): Добавление как последнего ребенка
     * - insertBefore(): Добавление перед указанным элементом
     * - append(): Добавление нескольких элементов (современный)
     * - prepend(): Добавление в начало
     */
    categorySelect.appendChild(option);
  });
}

// =============================================================================
// ОБРАБОТКА СОБЫТИЙ В JAVASCRIPT
// =============================================================================

/**
 * ТЕОРИЯ: Event Handling (Обработка событий)
 * 
 * Event Flow (Поток событий):
 * 1. Capture Phase: От window к целевому элементу
 * 2. Target Phase: На целевом элементе
 * 3. Bubble Phase: От целевого элемента к window
 * 
 * Event Object:
 * - target: Элемент, который вызвал событие
 * - currentTarget: Элемент, на котором висит обработчик
 * - type: Тип события
 * - preventDefault(): Отмена стандартного поведения
 * - stopPropagation(): Остановка распространения
 */

// === ПРЕДПРОСМОТР КАРТИНКИ ===
imageInput.addEventListener('change', () => {
  /**
   * ТЕОРИЯ: Event Listener для input type="file"
   * 
   * Событие change срабатывает когда:
   * - Пользователь выбирает файл через диалог
   * - Значение изменяется программно
   */
  
  // Берем первый выбранный файл
  /**
   * ТЕОРИЯ: FileList и File API
   * 
   * File Object свойства:
   * - name: Имя файла
   * - size: Размер в байтах
   * - type: MIME тип
   * - lastModified: Время последнего изменения
   */
  const file = imageInput.files[0];
  
  // Если файл действительно был выбран
  /**
   * ТЕОРИЯ: Truthy и Falsy значения в JavaScript
   * 
   * Falsy значения:
   * - false
   * - 0, -0, 0n
   * - "", '', ``
   * - null
   * - undefined
   * - NaN
   * 
   * Truthy: Все остальные значения
   */
  if(file) {
    // Создаем временную ссылку на этот файл
    /**
     * ТЕОРИЯ: URL.createObjectURL() и Blob URLs
     * 
     * Blob URL (Object URL):
     * - Ссылка вида blob:http://origin/UUID
     * - Ссылается на файл в памяти браузера
     * - Действительна только в текущей сессии
     * - Автоматически освобождается при закрытии страницы
     * 
     * Альтернативы:
     * - FileReader.readAsDataURL(): Data URL (base64)
     * - Service Worker для кэширования
     */
    const url = URL.createObjectURL(file);
    
    // Устанавливаем эту ссылку в картинку предпросмотра
    /**
     * ТЕОРИЯ: Загрузка изображений в браузере
     * 
     * Процесс загрузки:
     * 1. Установка src атрибута
     * 2. DNS lookup и HTTP запрос
     * 3. Загрузка данных
     * 4. Декодирование изображения
     * 5. Отображение на странице
     */
    preview.src = url;
    
    // Показываем картинку (она была скрыта)
    /**
     * ТЕОРИЯ: CSS и JavaScript манипуляция стилями
     * 
     * element.style vs CSS классы:
     * - style: inline стили (высокий приоритет)
     * - classList: управление CSS классами (рекомендуется)
     * 
     * display свойства:
     * - none: Полностью скрывает элемент
     * - block: Блочное отображение
     * - inline: Строчное отображение
     * - flex: Flexbox контейнер
     */
    preview.style.display = 'block';
  } else {
    // Если файл не выбран - прячем картинку предпросмотра
    preview.style.display = 'none';
  }
});

// =============================================================================
// ВАЛИДАЦИЯ ДАННЫХ И ФУНКЦИИ
// =============================================================================

/**
 * ТЕОРИЯ: Pure Functions (Чистые функции)
 * 
 * Характеристики чистых функций:
 * - Детерминированность: Одинаковый результат для одинаковых аргументов
 * - Отсутствие side effects: Не изменяет внешнее состояние
 * - Не зависит от внешнего состояния
 */

// === ПРОВЕРКА ЦЕНЫ ===
function isValidPrice(price) {
  /**
   * ТЕОРИЯ: Валидация пользовательского ввода
   * 
   * Уровни валидации:
   * 1. HTML5 Validation: required, pattern, min, max
   * 2. JavaScript Validation: Кастомная логика
   * 3. Server-side Validation: Финальная проверка
   */
  
  // Проверяем два условия:
  // 1. !isNaN(price) - это число? (не "Не Число")
  /**
   * ТЕОРИЯ: isNaN() vs Number.isNaN()
   * 
   * isNaN():
   * - Преобразует значение в число перед проверкой
   * - isNaN("123") → false (строка преобразуется)
   * - isNaN("abc") → true
   * 
   * Number.isNaN():
   * - Строгая проверка без преобразования
   * - Number.isNaN("123") → false
   * - Number.isNaN(NaN) → true
   */
  
  // 2. Number(price) >= 0 - число больше или равно нулю?
  /**
   * ТЕОРИЯ: Преобразование типов в JavaScript
   * 
   * Number():
   * - Number("123") → 123
   * - Number("123.45") → 123.45
   * - Number("") → 0
   * - Number("abc") → NaN
   * 
   * parseInt() vs Number():
   * - parseInt("123px") → 123 (игнорирует нечисловые символы)
   * - Number("123px") → NaN (строгое преобразование)
   */
  
  // Возвращаем true (правда) если оба условия выполнены, и false (ложь) если нет
  return !isNaN(price) && Number(price) >= 0;
}

// =============================================================================
// РАБОТА С ДАННЫМИ И СТРУКТУРАМИ
// =============================================================================

// === ДОБАВЛЕНИЕ ТОВАРА В ХРАНИЛИЩЕ ===
function addProductToStore(name, price, category, imageURL) {
  /**
   * ТЕОРИЯ: Мутабельность и иммутабельность в JavaScript
   * 
   * Мутабельные (изменяемые):
   * - Объекты
   * - Массивы
   * 
   * Иммутабельные (неизменяемые):
   * - Примитивы (string, number, boolean)
   * - const объявление (не делает значение иммутабельным)
   */
  
  // Проверяем, существует ли уже такая категория
  // Если нет - создаем новую пустую категорию
  /**
   * ТЕОРИЯ: Проверка существования свойств объекта
   * 
   * Способы проверки:
   * 1. obj.property !== undefined
   * 2. obj.hasOwnProperty('property')
   * 3. 'property' in obj
   * 4. Object.prototype.hasOwnProperty.call(obj, 'property')
   */
  if(!productStore.categories[category]) {
    /**
     * ТЕОРИЯ: Динамическое создание свойств объекта
     * 
     * bracket notation vs dot notation:
     * - dot: obj.property (статическое имя)
     * - bracket: obj[property] (динамическое имя)
     */
    productStore.categories[category] = [];
  }
  
  // Добавляем товар в массив выбранной категории
  /**
   * ТЕОРИЯ: Array.prototype.push() и мутационные методы
   * 
   * Мутационные методы массивов:
   * - push(), pop(), shift(), unshift()
   * - splice(), sort(), reverse()
   * 
   * Иммутабельные альтернативы:
   * - concat(), slice(), map(), filter()
   */
  productStore.categories[category].push({
    name: name,        // Название товара
    price: price + " Br", // Цена с добавлением "Br" (белорусские рубли)
    image: imageURL    // Ссылка на картинку
  });
}

// =============================================================================
// ОБРАБОТКА ФОРМ И ОШИБОК
// =============================================================================

// === ОБРАБОТКА ФОРМЫ ПРИ ОТПРАВКЕ ===
form.addEventListener('submit', e => {
  /**
   * ТЕОРИЯ: Form Submission Process
   * 
   * Стандартное поведение формы:
   * 1. Валидация HTML5 constraints
   * 2. Сбор данных формы
   * 3. HTTP запрос на action URL
   * 4. Перезагрузка страницы
   * 
   * preventDefault(): Отмена стандартного поведения
   */
  e.preventDefault();
  
  // Устанавливаем цвет сообщения по умолчанию (розовый)
  message.style.color = '#ff69b4';
  
  // Очищаем предыдущее сообщение
  message.textContent = '';

  // Получаем значения из всех полей формы и убираем лишние пробелы
  /**
   * ТЕОРИЯ: Form Data Access
   * 
   * Способы доступа к данным формы:
   * 1. form.elements: Коллекция элементов формы
   * 2. form.elementName: Прямой доступ по name
   * 3. new FormData(form): Современный API
   * 4. jQuery.serialize(): В jQuery
   */
  const name = form.name.value.trim();        // Название товара
  const price = form.price.value.trim();      // Цена
  const category = form.category.value;       // Категория
  const file = imageInput.files[0];           // Выбранный файл картинки

  // === ПРОВЕРКА ЗАПОЛНЕНИЯ ВСЕХ ПОЛЕЙ ===
  /**
   * ТЕОРИЯ: Falsy Values и валидация
   * 
   * Проверка на пустоту:
   * - !value: Проверяет falsy значения
   * - value === "": Только пустая строка
   * - value.trim() === "": Пустая строка с пробелами
   */
  if(!name || !price || !category || !file){
    message.textContent = 'Пожалуйста, заполните все поля.';
    return; // Останавливаем выполнение функции
    /**
     * ТЕОРИЯ: Early Return Pattern
     * 
     * Преимущества:
     * - Уменьшает вложенность кода
     * - Улучшает читаемость
     * - Легче отлаживать
     */
  }

  // === ПРОВЕРКА ЦЕНЫ ===
  if(!isValidPrice(price)){
    message.textContent = 'Цена должна быть положительным числом.';
    return; // Останавливаем выполнение функции
  }

  // ===========================================================================
  // ОБРАБОТКА ОШИБОК И ИСКЛЮЧЕНИЙ
  // ===========================================================================

  /**
   * ТЕОРИЯ: Error Handling в JavaScript
   * 
   * Механизмы обработки ошибок:
   * 1. try-catch-finally: Синхронные ошибки
   * 2. Promise.catch(): Асинхронные ошибки в Promise
   * 3. window.onerror: Глобальные ошибки
   * 4. Error Boundaries: В React
   */
  
  // Пытаемся выполнить этот код, и если что-то пойдет не так - поймаем ошибку
  try {
    /**
     * ТЕОРИЯ: Try Block
     * 
     * Код в try блоке:
     * - Выполняется нормально если нет ошибок
     * - При ошибке управление передается в catch
     * - Можно использовать return, но finally все равно выполнится
     */
    
    // Создаем временную ссылку для картинки
    const imageURL = URL.createObjectURL(file);

    // Добавляем товар в наше хранилище
    addProductToStore(name, price, category, imageURL);

    // Показываем сообщение об успехе зеленым цветом
    message.style.color = 'green';
    message.textContent = 'Товар успешно создан!';

    // Очищаем форму после успешного добавления
    /**
     * ТЕОРИЯ: HTMLFormElement.reset()
     * 
     * Метод reset():
     * - Возвращает форму к исходному состоянию
     * - Сбрасывает значения полей
     * - Не вызывает событие reset
     */
    form.reset();
    
    // Прячем превью картинки
    preview.style.display = 'none';

    // Выводим в консоль текущее состояние хранилища для проверки
    /**
     * ТЕОРИЯ: Console API для отладки
     * 
     * Методы console:
     * - log(): Обычное сообщение
     * - error(): Сообщение об ошибке
     * - warn(): Предупреждение
     * - info(): Информационное сообщение
     * - debug(): Отладочное сообщение
     * - table(): Табличное представление объектов
     */
    console.log('Текущий productStore:', productStore);

  } catch (err) {
    /**
     * ТЕОРИЯ: Catch Block
     * 
     * Параметр err:
     * - Объект Error или другое значение
     * - Содержит сообщение об ошибке
     * - Имеет stack trace для отладки
     */
    
    // Если что-то пошло не так в блоке try - выполняем этот код
    // Выводим ошибку в консоль для разработчика
    console.error(err);
    
    // Показываем пользователю сообщение об ошибке
    message.textContent = 'Произошла ошибка при создании товара.';
  }
  
  /**
   * ТЕОРИЯ: Finally Block (отсутствует здесь)
   * 
   * finally блок:
   * - Выполняется всегда, независимо от результата
   * - Полезен для очистки ресурсов
   * - Выполняется даже при return в try/catch
   */
});

// =============================================================================
// ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ
// =============================================================================

// === ЗАПУСКАЕМ ПРОГРАММУ ===
// Вызываем функцию заполнения категорий при загрузке страницы
/**
 * ТЕОРИЯ: Инициализация приложения
 * 
 * Время инициализации:
 * - DOMContentLoaded: Когда DOM готов
 * - load: Когда все ресурсы загружены
 * - Immediately: Как в данном случае (скрипт в конце body)
 * 
 * Паттерны инициализации:
 * - IIFE: (function(){ ... })()
 * - Module Pattern
 * - Class-based initialization
 */
initCategories();

/**
 * ТЕОРИЯ: Module Pattern и глобальное пространство имен
 * 
 * Проблемы глобальных переменных:
 * - Загрязнение глобального пространства имен
 * - Возможность конфликтов
 * - Сложность тестирования
 * 
 * Решения:
 * - IIFE с возвратом публичного API
 * - ES6 Modules (import/export)
 * - Namespace объекты
 */